import configparser
import os
import time
from datetime import datetime

from utils.loggerObj import LoggerObj
from openpyxl.styles.borders import Border, Side
import openpyxl as excel
from openpyxl.styles.borders import Border, Side
from openpyxl.utils import get_column_letter

import numpy as np
import pandas as pd

from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.ui import Select, WebDriverWait


class SeleniumExecuteBase():

    # 出力結果を格納するパス
    resultFilePath = []

    # テスト用かどうかの呼び分けを行う mode=1のときテスト用 testBaseFilePathはテスト用の設定ファイルの位置
    def init(self,
             iniFile,
             mode=0,
             filePaths=[
                 'testfiles/resources/testCaseConfig.ini',
                 'testfiles/resources/testCaseConfig.ini'
             ]):
        if mode == 0:
            # 共通で使う項目を定義 設定ファイルを読み込む
            iniFile.read(filePaths[0], "UTF-8")
            iniFile.read(filePaths[1], "UTF-8")
        elif mode == 1:
            # テスト時はこちらを読み込む
            iniFile.read(filePaths[0], "UTF-8")
            iniFile.read(filePaths[1], "UTF-8")
        else:
            log = LoggerObj()
            log.error('mode不正')

    # 出力結果のディレクトリを格納単体テストの時にこのパスを受け取って比較を行う
    def setResultPath(self, filePath):
        self.resultFilePath = filePath

    # 出力結果が入っているパスを返す
    def getResultPath(self):
        return self.resultFilePath

    # webdriver用の設定をもろもろ行って返却する
    def createWebDriver(self, iniFile):
        # Edgeの場合
        #driver = webdriver.Edge(iniFile.get("commonSetting","webDriverEdgePath"))
        # FireFoxの場合
        binary = FirefoxBinary(iniFile.get("commonSetting", "fireFoxPath"))
        caps = DesiredCapabilities().FIREFOX
        caps["marionette"] = True
        driver = webdriver.Firefox(
            capabilities=caps,
            firefox_binary=binary,
            executable_path=iniFile.get("commonSetting",
                                        "webDriverFireFoxPath"))
        return driver

    # 黒い罫線を返すエクセルのセルに黒で罫線を引きたいときに使用する
    def blackBorderLine(self):
        border = Border(
            top=Side(style='thin', color='000000'),
            bottom=Side(style='thin', color='000000'),
            left=Side(style='thin', color='000000'),
            right=Side(style='thin', color='000000'))

        return border

    # エラー情報をまとめて出力する
    # ディレクトリに付与する年月日時分、CSVのヘッダー、エラー情報をまとめている辞書を引数として渡す
    def outPutErrorInfoCSV(self,iniFile,colums,errorInfoDict,csvFileName='ErrorInfo',targetDateHourMinute=datetime.now().strftime("%Y%m%d%H%M")):
        errorInfoDirectry = iniFile.get(
            "files", "errorInfoDirectry") + targetDateHourMinute
        os.makedirs(errorInfoDirectry, exist_ok=True)

        errorInfoDataFrame=pd.DataFrame(columns=colums)
        indexCount=1
        for key,dataList in errorInfoDict.items():
            for data in dataList:
                # キーの情報、各種情報のリストの形でまとめる
                infoList=[key]
                infoList.extend(data)
                errorInfoSeries=pd.Series(infoList,index=colums,name=indexCount)
                indexCount=indexCount+1
                errorInfoDataFrame=errorInfoDataFrame.append(errorInfoSeries)
        
        errorOutputFileName=errorInfoDirectry+'/{0}.csv'.format(csvFileName)
        if os.path.isfile(errorOutputFileName):
            # 同じファイルが存在する場合は上書きしないように別のファイル名にする
            errorOutputFileName=errorOutputFileName+'_'+datetime.now().strftime("%Y%m%d%H%M%S")

        errorInfoDataFrame.to_csv(errorOutputFileName,encoding='shift_jisx0213')
        return errorOutputFileName

    # エラー情報をまとめて出力する
    # ディレクトリに付与する年月日時分、エクセルのヘッダー、エラー情報をまとめている辞書を引数として渡す
    def outPutErrorInfoExcel(self,iniFile,colums,errorInfoDict,csvFileName='ErrorInfo',targetDateHourMinute=datetime.now().strftime("%Y%m%d%H%M")):
        errorInfoDirectry = iniFile.get(
            "files", "errorInfoDirectry") + targetDateHourMinute
        os.makedirs(errorInfoDirectry, exist_ok=True)
        errorInfoDataFrame=pd.DataFrame(columns=colums)
        indexCount=1
        for key,dataList in errorInfoDict.items():
            # キーの情報、各種情報のリストの形でまとめる
            for datas in dataList: 
                infoList=[key]
                dList=list(datas)
                infoList.extend(dList)
                errorInfoSeries=pd.Series(infoList,index=colums,name=indexCount)
                indexCount=indexCount+1
                errorInfoDataFrame=errorInfoDataFrame.append(errorInfoSeries)
        
        errorOutputFileName=errorInfoDirectry+'/{0}.xlsx'.format(csvFileName)
        if os.path.isfile(errorOutputFileName):
            # 同じファイルが存在する場合は上書きしないように別のファイル名にする
            errorOutputFileName=errorOutputFileName+'_'+datetime.now().strftime("%Y%m%d%H%M%S")

        # 結果を一度エクセルに出力
        errorInfoDataFrame.to_excel(errorOutputFileName,encoding='shift_jisx0213')

        # 罫線を引くようの設定
        border = self.blackBorderLine()

        # ヘッダーの色付け
        fill = excel.styles.PatternFill(patternType='solid',
                                        fgColor='87ceeb', bgColor='87ceeb')


        # フォーマットを整える
        targetBook=excel.load_workbook(errorOutputFileName)
        sheet=targetBook.active
        columLength=len(colums)
        for index in range(0,columLength+1):
            if index==0:
                continue
            if index==1:
                sheet.column_dimensions[get_column_letter(2)].width=56
            else:
                sheet.column_dimensions[get_column_letter(index+1)].width=20

        for index,row in enumerate(sheet.rows):
            for cell in row:
                cell.border=border
                if index==0:
                    cell.fill=fill

        targetBook.save(filename=errorOutputFileName)
        return errorOutputFileName


# メイン処理
if __name__ == "__main__":
    print('CreateFileBase')